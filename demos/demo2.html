<!DOCTYPE html>
<html xmlns='http://www.w3.org/1999/xhtml' xml:lang='en' lang='en'>
  <head>
    <meta http-equiv='Content-Type' content='text/html; charset=utf-8'/>
    <title>Real time ASCII Raytracer in Javascript</title>
    <style type="text/css">
    #screen {
        font-family: 'courier, monospace';
        font-size: 8pt;
        font-weight: normal;
        line-height: 0.5em;
        letter-spacing: -50%;
    }
    </style>
  </head>
  <body>
    <h2>Javascript ASCII Raytracing</h2>
    <div>
      <label for='width'>Width</label>
      <input type='text' name='width' id='width' size='3' value='100'/>
      <label for='height'>Height</label>
      <input type='text' name='height' id='height' size='3' value='80'/>
      <button onclick='render()'>Render!</button>
      <button onclick='stop()'>Stop!</button>
      <div id='camera'></div>
    </div>
    <div id='zone'></div>
    <pre id='log'></pre>
    <div id='screen'>
    </div>
  </body>
  <script src='http://ajax.googleapis.com/ajax/libs/jquery/1.6.2/jquery.min.js' type='text/javascript'></script>
  <script type='text/javascript'>
(function (GLOBAL) {
    GLOBAL.AsciiTracer = {
        buildCanvas:    function (parent, width, height) {
            var can = GLOBAL.document.createElement("canvas");
            can.width = width;
            can.height = height;
            parent.appendChild(can);
            return can.getContext("2d");
        },
        writeImage:    function (scene, ctx, width, height) {
            // var palette = ' \u22c5\u2236\u2234\u2235\u2237\u223b\u2249\u224b\u2247'.split('').reverse();
            var palette = ' \u2591\u2592\u2593\u2588'.split('').reverse();
            var div = $('#screen');
            var htmlContent = ['<pre>'];

            this.prepareScene(scene);
            var aspectRatio = width / height;
            var idx=1;
            var n = width * height;
            var height_inv = 1.0 / height;
            var width_inv = 1.0 / width;
	        var plen = palette.length - 1;
	    
            for (var y = 0; y < height; y++) {
                for (var x = 0; x < width; x++) {
                    var yRec = (-y * height_inv) + 0.5;
                    var xRec = ((x * width_inv) - 0.5) * aspectRatio;
                    var luma = this.plotPixel(scene, xRec, yRec);

                    htmlContent[idx++] = palette[Math.floor(plen * luma)];
                }
                htmlContent[idx++] = '\n';
            }
            htmlContent[idx++] = '</pre>';
            div.html(htmlContent.join(''));
        },
        vectorAdd:    function (v1, v2) {
            return [v1[0]+v2[0], v1[1]+v2[1], v1[2]+v1[2]];
        },
        vectorSub:    function (v1, v2) {
            return [v1[0]-v2[0], v1[1]-v2[1], v1[2]-v2[2]];
        },
        vectorNeg:    function (v1) {
            return [-v1[0], -v1[1], -v1[2]];
        },
        vectorScale:    function (v1, x) {
            return [v1[0]*x, v1[1]*x, v1[2]*x];
        },
        vectorDot:    function (v1, v2) {
            return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
        },
        vectorCross3:    function (v1, v2) {
            return [v1[1] * v2[2] - v1[2] * v2[1],
                    v1[2] * v2[0] - v1[0] * v2[2],
                    v1[0] * v2[1] - v1[1] * v2[0]];
        },
        vectorBlend:    function (v1, v2) {
            return [v1[0]*v2[0], v1[1]*v2*[1], v1[2]*v2[2]];
        },
        vectorLength:    function (v1) {
            return Math.sqrt(v1[0]*v1[0] + v1[1]*v1[1] + v1[2]*v1[2]);
        },
        vectorNormalize:    function (v1) {
            var fact = 1.0 / Math.sqrt(v1[0]*v1[0] + v1[1]*v1[1] + v1[2]*v1[2]);
            return [v1[0]*fact, v1[1]*fact, v1[2]*fact];
        },
        vectorAdd:  function(v1, v2) {
            return [v1[0]+v2[0], v1[1]+v2[1], v1[2]+v2[2]];
        },
        vectorSum:    function () {
            var vecs = [];
            for (var i = 0; i < arguments.length; i++) vecs.push(arguments[i]);
            return this.vectorSumArray(vecs);
        },
        vectorSumArray:    function (vecs) {
            var res = [0,0,0];
            for (var i = 0; i < vecs.length; i++) {
                var v = vecs[i];
                res[0] += v[0];
                res[1] += v[1];
                res[2] += v[2];
            }
            return res;
        },
        plotPixel:    function (scene, x, y) {
            var cam = scene.camera;
            var rayDir = [];
            rayDir[0] = cam.forward[0] + x*cam.right[0] + y*cam.up[0];
            rayDir[1] = cam.forward[1] + x*cam.right[1] + y*cam.up[1];
            rayDir[2] = cam.forward[2] + x*cam.right[2] + y*cam.up[2];
            var fact = 1.0 / Math.sqrt(rayDir[0]*rayDir[0] + rayDir[1]*rayDir[1] + rayDir[2]*rayDir[2]);
            rayDir[0] *= fact;
            rayDir[1] *= fact;
            rayDir[2] *= fact;

            // don't you wish we had inline functions in javascript?
            
            /*
            above code accomplishes this:
            var rayDir = this.vectorNormalize(
                    this.vectorAdd(
                        cam.forward, 
                        this.vectorAdd(this.vectorScale(cam.right, x), this.vectorScale(cam.up, y))
                    )
            );
            */

            var luma = this.traceRay(scene, cam.position, rayDir, null, 1);
            if (luma < 0) luma = 0;
            else if (luma > 1.0) luma = 1.0;
            return luma;
        },
        shapeIntersect:    function (start, dir, shape) {
            switch (shape.type) {
                case 0:
                    return this.intersectPlane(start, dir, shape);
                case 1:
                    return this.intersectSphere(start, dir, shape);
                default:
                    return [];
            };
        },
        intersectPlane:    function (start, dir, plane) {
            var denom = this.vectorDot(dir, plane.normal);
            if (denom == 0) return;
            var res = plane.offset - this.vectorDot(start, plane.normal) / denom;
            if (res <= 0) return;
            return res;
        },
        intersectSphere:    function (start, dir, sphere) {
            var y = this.vectorSub(start, sphere.centre);
            var beta = this.vectorDot(dir, y),
                gamma = this.vectorDot(y, y) - sphere.radius * sphere.radius;
            var descriminant = beta * beta - gamma;
            if (descriminant <= 0) return;
            var sqrt = Math.sqrt(descriminant);
            if (-beta - sqrt > 0) return -beta - sqrt;
            else if (-beta + sqrt > 0) return -beta + sqrt;
            else return;
        },
        shapeNormal:    function (pos, shape) {
            switch (shape.type) {
                case 0:
                    return shape.normal;
                case 1:
                    return this.sphereNormal(pos, shape);
                default:
                    return [];
            };
        },
        sphereNormal:    function (pos, sphere) {
            return this.vectorScale(this.vectorSub(pos, sphere.centre), 1/sphere.radius);
        },
	    shade:    function (pos, dir, shape, scene, contrib) {
            var mat = this.material(shape.surface, pos);
            var norm = this.shapeNormal(pos, shape);
            var reflect = mat[1];
            contrib = contrib * reflect;
            norm = (this.vectorDot(dir, norm) > 0) ? -norm : norm;
            var reflectDir = this.vectorSub(dir, this.vectorScale(norm, 2 * this.vectorDot(norm, dir)));
            var light = this.light(scene, shape, pos, norm, reflectDir, mat);
            if (contrib > 0.1) { // 0.01
                return light + reflect * this.traceRay(scene, pos, reflectDir, shape, contrib);
            }
            else {
                return light;
            }
        },
        light:    function (scene, shape, pos, norm, reflectDir, mat) {
            var color = mat[0],
                reflect = mat[1],
                smooth = mat[2];
            var res = 0;
            for (var i = 0; i < scene.lights.length; i++) {
                var lCol = scene.lights[i].color,
                    lPos = scene.lights[i].position;

                var lDir = [];
                lDir[0] = lPos[0] - pos[0];
                lDir[1] = lPos[1] - pos[1];
                lDir[2] = lPos[2] - pos[2];
                var lDist = Math.sqrt(lDir[0]*lDir[1]+lDir[1]*lDir[1]+lDir[2]*lDir[2]);
                var fact = 1.0 / lDist;
                lDir[0] *= fact;
                lDir[1] *= fact;
                lDir[2] *= fact;

                var tRay = this.testRay(scene, pos, lDir, shape);
                var skip = false;
                for (var j = 0; j < tRay.length; j++) {
                    if (tRay[j] < lDist) {
                        skip = true; // XXX use label
                        break;
                    }
                }
                if (skip) continue;
                var illum = this.vectorDot(lDir, norm);
                if (illum > 0) res += lCol * color * illum; 
                var spec = this.vectorDot(lDir, reflectDir);
                if (spec > 0) res += lCol * Math.pow(spec, smooth) * reflect; 
            }
            return res;
        },
        material:    function (name, pos) {
            switch(name) {
                case 0:
                    return [1, 0.6, 50];
                case 1:
                    return ((Math.floor(pos[0]) + Math.floor(pos[2])) % 2) == 0 ?
                            [0, 0.7, 150] :
                            [1, 0.1, 50];
            }
            return;
        },
        testRay:    function (scene, src, dir, curShape) {
            var res = [];
            for (var i = 0; i < scene.shapes.length; i++) {
                var shape = scene.shapes[i];
                if (shape.id == curShape.id) continue;
                var inter = this.shapeIntersect(src, dir, shape);
                if (inter != null) res.push(inter);
            }
            return res;
        },        
        traceRay:    function (scene, src, dir, ignore, contrib) {
            var tmp = [];
            for (var i = 0; i < scene.shapes.length; i++) {
                var shape = scene.shapes[i];
                if (ignore && ignore.id == shape.id) continue;
                var dist = this.shapeIntersect(src, dir, shape);
                if (dist == null) continue; // XXX optimisation
                var pos = this.vectorAdd(src, this.vectorScale(dir, dist));
                tmp.push({dist: dist, pos: pos, shape: shape});
            }
            if (tmp.length == 0) return scene.background;
            else {
                tmp = tmp.sort(function (a, b) { return a.dist - b.dist; });
                return this.shade(tmp[0].pos, dir, tmp[0].shape, scene, contrib);
            }
        },
        calculateBasis:    function (scene) {
            var cam = scene.camera;
            cam.forward = this.vectorNormalize(this.vectorSub(cam.lookAt, cam.position));
            cam.right = this.vectorNormalize(this.vectorCross3(cam.forward, [0, -1, 0]));
            cam.up = this.vectorCross3(cam.forward, cam.right);
        },
        prepareScene:    function (scene) {
            this.calculateBasis(scene);
        },
        traceTo:    function (parent, width, height, scene) {
            this.writeImage(scene, null, width, height);
        },
    };
})(this);
    var interval=null;
    function log (str) {
        document.getElementById("log").textContent += str + "\n";
    }
    function stop() {
        if (interval) {
            clearInterval(interval);
        }
    }
    function render () {
        stop();
        var w = document.getElementById("width").value,
            h = document.getElementById("height").value,
            zone = document.getElementById("zone");

        cameraDiv = document.getElementById('camera');
        var camera_velocities = [
            [0, 0, -1, 35],
            [-1, 0, 0, 30],
            [0, 0, 1, 35],
            [1, 0, 0, 30],
            [0.3, 0.3, 0, 5],
        ];
        var vel_idx = 0;
        var frame = 0; 
      
        interval = setInterval(function() {
            scene.camera.position = AsciiTracer.vectorAdd(scene.camera.position, AsciiTracer.vectorScale(camera_velocities[vel_idx], 0.2));
            //cameraDiv.innerHTML = camera_velocities[vel_idx] + " vel_idx = " + vel_idx + ", frame: " + frame;
            
            AsciiTracer.traceTo(zone, w, h, scene);
            frame++;
            if (frame == camera_velocities[vel_idx][3]) {
                vel_idx = (vel_idx + 1) % camera_velocities.length;
                frame = 0;
            }
        }, 1);

    }
    var scene = {
        background: 0.6,
        shapes:     [
           {    // checkerboard plane
                id:       0,
                type:     0,  // plane
                offset:   0,
                surface:  1, // checkerboard
                normal: [0, 1, 0]
            },
            {   // big sphere
                id:       2,
                type:     1, // sphere
                radius:   1,
                surface:  0, // shiny
                centre:   [0, 1.0, 0],
            },
            {    // sphere
                id:       3,
                type:     1,
                radius:   0.5,
                surface:  0,
                centre:   [-1, 0.5, 1.5],
            },
        ],
        camera: {
            position: [3, 0.2, 4], 
            lookAt:   [-1, 0.5, 0],
        },
        lights: [
        /*
            {
                position: [-2, 2.5, 0],
                //color:   [0.49, 0.07, 0.07]
                color: [0.5, 0.5, 0.5]
            },
            */
            {
                position: [0.0, 7.0, 0.0],
                color: 1.0,
            },
            {
                position: [1.5, 2.5, 1.5],
                color: 1.0,
            },
            /*
            {
                position: [1.5, 2.5, -1.5],
                //color:   [0.07, 0.49, 0.07]
                color: [0.5, 0.5, 0.5]
            },
            */
            /*
            {
                position: [0, 3.5, 0],
                color:   [0.21, 0.21, 0.35]
            },
            */
        ]
    };
  </script>
</html>
